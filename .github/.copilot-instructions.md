# Copilot Rules

This file contains coding guidelines and rules for this project to help GitHub Copilot provide better suggestions.

## Tests

### Import Rules

- Always use full relative path imports for mock functions
  - Example: `import { mockFunction } from '../../../mock/services'` instead of `import { mockFunction } from '@/mock/services'`
  - This ensures clarity and avoids potential path resolution issues in test environments

### Test Execution

- Always use the command `npm run test <route to file or folder>` when running tests
  - Example: `npm run test src/components/header`
  - Example: `npm run test src/actions/auth/auth.test.ts`
  - This ensures consistent test execution across the project

### Mock Organization

- Group all `jest.mock()` calls at the top of test files, immediately after imports
- Use relative paths for internal mocks (components, utils, etc.)
- Use absolute paths only for external libraries
- Always include `__esModule: true` when mocking ES modules
- Provide meaningful mock implementations that match the original API

### Test Structure

- Use descriptive test suite names: `"ComponentName Test Suite"` format
- Group related tests using nested `describe` blocks
- Use clear, descriptive test names that explain the expected behavior
- Follow the pattern: `"should [expected behavior] when [condition]"`
- Example: `"should render loading state when data is being fetched"`

### Mock Data

- Define mock data objects outside of test functions for reusability
- Use TypeScript types for mock data to ensure type safety
- Name mock data with `mock` prefix: `mockItems`, `mockUser`, `mockResponse`
- Create realistic mock data that matches production data structures

### Assertions and Testing Patterns

- Always use `@testing-library/jest-dom` for better assertions
- Prefer `screen.getByTestId()` over `container.querySelector()` for element selection
- Use `waitFor()` for asynchronous operations and state changes
- Include snapshot tests for component rendering stability
- Test both success and error states for components with API calls

### Cleanup and Setup

- Use `beforeEach()` to clear mocks and reset state between tests
- Use `afterEach()` to restore any spied functions
- Avoid DOM pollution by using proper cleanup between tests
- Mock `console.error` and `console.warn` when testing error scenarios

### Test Data Attributes

- Use `data-testid` attributes for test-specific element selection
- Follow naming convention: `data-testid="component-element-state"`
- Example: `data-testid="article-title"`, `data-testid="loading-spinner"`

## General Guidelines

- Follow the existing project structure and naming conventions
- Use TypeScript for all new files
- Maintain consistent code formatting and style
